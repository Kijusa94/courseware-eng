{
  "hash": "fdad93218b6c748bda1b6b4917ef6282",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Programación  \nsubtitle: \"Fundamentos\"\nauthor: M.Sc. Juan Guzman\ninstitute: Fundación Uinversitaria de Popayán\n---\n\n# Funciones \n\n## ¿Qué son las funciones?\n\nSon fragmentos o bloques de código que realizan una tarea específica.\n\n\n* Permiten ejecutar las mismas tareas más de una vez sin repetir código.\n* Pueden recibir diferentes parámetros/valores (Recursividad).\n\n::: {.callout-note}\n**Partes de una función:**\n1. Definición (sentencias).\n2. Llamado (ejecución).\n:::\n\n## Estructura Básica\nUtilizamos la palabra reservada ``def``.\n\n::: {#45c74905 .cell execution_count=1}\n``` {.python .cell-code}\ndef Factorial(num):\n    resultado = 1\n    for i in range(num):\n        resultado *= i + 1 \n    return resultado # Parámetro de salida\n\n# Llamado de la función\nprint(Factorial(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n```\n:::\n:::\n\n\n## Contexto (Scope) {.smaller}\n\nEl alcance de las variables depende de dónde se declaren.\n\n* **Variables Globales:** Manipulables en todo el programa.\n* **Variables Locales:** Accesibles solo dentro del bloque/función.\n\n::: {#22d26522 .cell execution_count=2}\n``` {.python .cell-code}\nvar_global = 7\n\ndef funcionContexto(parametro):\n    var_local = 100\n    print(f'Local: {var_local} - Global: {var_global}')\n\nfuncionContexto('test')\n# print(var_local) # Esto generaría un ERROR\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLocal: 100 - Global: 7\n```\n:::\n:::\n\n\n## Modificando Globales\n\nPara editar una variable global dentro de una función, usamos la palabra clave `global`.\n\n::: {#2024c2b7 .cell execution_count=3}\n``` {.python .cell-code}\nvariable = 10\n\ndef cambiar_global():\n    global variable\n    variable = 20\n\ncambiar_global()\nprint(f\"Nuevo valor: {variable}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNuevo valor: 20\n```\n:::\n:::\n\n\n## Ejemplo: Permutaciones\n\nCalculamos  usando funciones para no repetir la lógica del factorial.\n\n::: {#2428bf17 .cell execution_count=4}\n``` {.python .cell-code}\ndef Factorial(num):\n    res = 1\n    for i in range(num): res *= i + 1 \n    return res\n\nN = 5\nr = 2\nresultado = Factorial(N) / Factorial(N-r)\nprint(f\"Permutación {N}P{r} = {resultado}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPermutación 5P2 = 20.0\n```\n:::\n:::\n\n\n# Cadenas de Texto y Codificación \n\n## Manipulación de Strings\n\nPodemos concatenar y organizar cadenas extensas.\n\n::: {#2ea9bba1 .cell execution_count=5}\n``` {.python .cell-code}\n# Concatenación\nc1 = \"Hola \"\nc2 = \"Mundo\"\nprint(c1 + c2)\n\n# Multilínea con comilla triple\ntexto = '''Esto es un texto\nque respeta los saltos\nde línea.'''\nprint(texto)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHola Mundo\nEsto es un texto\nque respeta los saltos\nde línea.\n```\n:::\n:::\n\n\n## Slicing (Rebanado)\n\nPodemos extraer trozos de la cadena usando índices `[inicio:fin]`.\n\n::: {#84354cbd .cell execution_count=6}\n``` {.python .cell-code}\ncadena = \"Programación en Python\"\n\nprint(cadena[0:12])  # 'Programación'\nprint(cadena[-6:])   # 'Python'\nprint(len(cadena))   # Longitud total\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProgramación\nPython\n22\n```\n:::\n:::\n\n\n## Métodos de Strings\n\nLas cadenas son objetos que tienen funciones asociadas (métodos).\n\n::: {#5f50358a .cell execution_count=7}\n``` {.python .cell-code}\ntexto = \"curso de python\"\n\nprint(texto.upper())          # Mayúsculas\nprint(texto.title())          # Título\nprint(texto.replace('o', '0'))# Reemplazo\nprint(texto.split())          # Convertir a lista\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCURSO DE PYTHON\nCurso De Python\ncurs0 de pyth0n\n['curso', 'de', 'python']\n```\n:::\n:::\n\n\n> Podemos encadenar métodos: `texto.lower().find('python')`\n\n## Codificación de Caracteres\n\n* **ASCII:** Estándar original (128 caracteres). Limitado.\n* **Unicode (UTF-8):** Universal, uniforme y único. Permite todos los idiomas y emojis.\n\nFunciones de conversión:\n\n::: {#dc84abb8 .cell execution_count=8}\n``` {.python .cell-code}\nprint(ord('@'))  # Caracter a Código (ASCII/Unicode)\nprint(chr(64))   # Código a Caracter\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n64\n@\n```\n:::\n:::\n\n\n## Ejemplo: Cifrado César\n\nDesplazamiento de caracteres usando su valor numérico.\n\n::: {#24b2b212 .cell execution_count=9}\n``` {.python .cell-code}\nmensaje = \"HOLA\"\ncifrado = \"\"\ndesp = 1\n\nfor letra in mensaje:\n    cifrado += chr(ord(letra) + desp)\n\nprint(f\"Original: {mensaje} -> Cifrado: {cifrado}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal: HOLA -> Cifrado: IPMB\n```\n:::\n:::\n\n\n# Módulos y Paquetes \n\n## ¿Qué es un módulo?\n\nArchivos que agrupan funciones relacionadas para no \"reinventar la rueda\".\n\nEjemplo con librería matemática:\n\n::: {#49650033 .cell execution_count=10}\n``` {.python .cell-code}\nimport math\n\nprint(math.cos(math.pi))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-1.0\n```\n:::\n:::\n\n\n## Instalación de Paquetes\n\nSi el módulo no está instalado, usamos gestores de paquetes en la terminal:\n\n::: {.callout-tip}\n**Comandos de instalación**\n\n* Anaconda: `conda install nombre_del_modulo`\n* Python estándar: `pip install nombre_del_modulo`\n* Listar paquetes: `pip list`\n:::\n\n## Estructura de Proyectos\n\nSe recomienda organizar los archivos en paquetes (carpetas con `__init__.py` o namespace).\n\n```text\nsrc/\n    principal.py\n    paquete_datos/\n        transacciones.py\n    paquete_visualizacion/\n        graficas.py\nassets/\n    images/\n        logo.png\n    language/\n        es.json\n\n```\n\n# Manejo de Archivos \n\n## Apertura de Archivos\n\nUsamos la función `open(ruta, modo)`.\n\n| Modo | Descripción | Puntero |\n| --- | --- | --- |\n| `r` | Solo lectura | Inicio |\n| `w` | Escritura (Sobreescribe) | Inicio |\n| `a` | Añadido (Append) | Final |\n| `r+` | Lectura y Escritura | Inicio |\n\n## Lectura\n\nExisten varios métodos para extraer información.\n\n::: {#830a1af3 .cell execution_count=11}\n``` {.python .cell-code}\n# Creamos un archivo de prueba\nf = open('test.txt', 'w')\nf.write(\"Línea 1\\nLínea 2\")\nf.close()\n\n# Lectura\narchivo = open('test.txt', 'r')\ncontenido = archivo.read() # Lee todo\nprint(contenido)\narchivo.close()\n```\n:::\n\n\n## Lectura Línea a Línea\n\nPara archivos grandes o procesamiento secuencial.\n\n::: {#0c79f0e3 .cell execution_count=12}\n``` {.python .cell-code}\narchivo = open('test.txt', 'r')\n# readline() lee una sola linea y mueve el puntero\nprint(archivo.readline().strip()) \narchivo.close()\n```\n:::\n\n\n## Buenas Prácticas (With)\n\nLa estructura `with` maneja el contexto y cierra el archivo automáticamente, incluso si hay errores.\n\n::: {#478e94f5 .cell execution_count=13}\n``` {.python .cell-code}\nwith open('test.txt', 'r') as archivo:\n    for linea in archivo:\n        print(f\">> {linea.strip()}\")\n        \n# Aquí el archivo ya está cerrado\n```\n:::\n\n\n## Punteros (Seek & Tell)\n\nControl manual de la posición en el archivo.\n\n* `tell()`: Nos dice dónde está el puntero.\n* `seek(byte)`: Mueve el puntero a una posición específica.\n\n::: {#32616871 .cell execution_count=14}\n``` {.python .cell-code}\nwith open('test.txt', 'r') as f:\n    f.read() # Leemos todo\n    print(f\"Posición final: {f.tell()}\")\n    f.seek(0) # Volvemos al inicio\n    print(f\"Posición tras seek: {f.tell()}\")\n```\n:::\n\n\n",
    "supporting": [
      "programming_03_funcs_files\\figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}