{
  "hash": "84138c6d2d34b4cfcf64280a6cce4a56",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Programación  \nsubtitle: \"Fundamentos\"\nauthor: M.Sc. Juan Guzman\ninstitute: Kijusa94\n---\n\n# Introducción a Pandas \n\n## ¿Qué es Pandas?\n\n\nEs una librería optimizada para trabajar con estructuras de datos matriciales (filas y columnas) y series temporales.\n\n::: {.incremental}\n- **Versatilidad:** Trabaja con CSV, Excel, SQL, JSON.\n- **Tipos de datos:** A diferencia de Numpy, Pandas maneja datos mixtos (números, texto, fechas).\n- **Estructuras Principales:**\n    1. **Series:** Unidimensional (Vector).\n    2. **DataFrame:** Bidimensional (Tabla).\n:::\n\n## La Estructura \"Series\"\nContiene dos arrays: el **índice** y los **datos**.\n\n::: {#df99a7e3 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport random\n\n# Serie simple con índice automático (0, 1, 2...)\ns = pd.Series(['Enero', 'Febrero', 'Marzo'])\n\n# Serie con índice personalizado\ns_index = pd.Series([10, 20, 30], index=['a', 'b', 'c'])\n\nprint(s_index)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na    10\nb    20\nc    30\ndtype: int64\n```\n:::\n:::\n\n\n## Operaciones en Series\n\nPodemos aplicar funciones matemáticas y acceder como si fueran listas.\n\n::: {#64f8d466 .cell execution_count=2}\n``` {.python .cell-code}\n# Generamos datos aleatorios\ndatos = [random.randrange(1, 50) for i in range(5)]\ns = pd.Series(datos)\n\nprint(f\"Valor en pos 2: {s[2]}\")\nprint(f\"Suma total: {s.sum()}\")\nprint(f\"Promedio: {s.mean()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nValor en pos 2: 44\nSuma total: 106\nPromedio: 21.2\n```\n:::\n:::\n\n\n# DataFrames: Tablas de Datos \n\n## Creación de DataFrames\n\nPodemos construirlos desde listas de tuplas o diccionarios.\n\n**Opción A: Diccionarios** (Clave = Columna)\n\n::: {#52dcf934 .cell execution_count=3}\n``` {.python .cell-code}\ndf = pd.DataFrame({\n    'Mes': ['Enero','Febrero'], \n    'Casos': [177643, 33727], \n    'UCI': [996, 333] \n})\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Mes   Casos  UCI\n0    Enero  177643  996\n1  Febrero   33727  333\n```\n:::\n:::\n\n\n## Inspección de Datos\n\nMétodos esenciales para conocer nuestro Dataset.\n\n* `df.head()`: Muestra las primeras filas.\n* `df.info()`: Tipos de datos y valores nulos.\n* `df.describe()`: Estadísticas descriptivas (media, min, max, cuartiles).\n* `df.columns`: Lista de encabezados.\n\n::: {#f260582f .cell output-location='fragment' execution_count=4}\n``` {.python .cell-code}\nprint(df.describe())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               Casos         UCI\ncount       2.000000    2.000000\nmean   105685.000000  664.500000\nstd    101763.979521  468.811796\nmin     33727.000000  333.000000\n25%     69706.000000  498.750000\n50%    105685.000000  664.500000\n75%    141664.000000  830.250000\nmax    177643.000000  996.000000\n```\n:::\n:::\n\n\n# Acceso y Selección de Datos \n\n## Tipos de Indexación\n\nPandas ofrece dos formas robustas de seleccionar datos:\n\n1. **Por Posición (iloc):** Usa índices numéricos (como matrices).\n2. **Por Etiqueta (loc):** Usa los nombres de filas/columnas.\n\n::: {.callout-warning}\nEl acceso directo `df['Columna']` sirve para columnas, pero para precisión se recomienda `loc` o `iloc`.\n:::\n\n## Uso de `iloc` (Posición) {.smaller}\n\nSintaxis: `df.iloc[<filas>, <columnas>]`\n\n::: {#0224326f .cell execution_count=5}\n``` {.python .cell-code}\ndf = pd.DataFrame(\n    data=[('Enero',100), ('Febrero',200), ('Marzo',300)],\n    columns=['Mes','Ventas'], index=['a','b','c']\n)\n\n# Selecciones\nprint(df.iloc[0])       # Primera fila\nprint(df.iloc[:, 1])    # Segunda columna (todas las filas)\nprint(df.iloc[0:2])     # Rango (exclusivo el final)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMes       Enero\nVentas      100\nName: a, dtype: object\na    100\nb    200\nc    300\nName: Ventas, dtype: int64\n       Mes  Ventas\na    Enero     100\nb  Febrero     200\n```\n:::\n:::\n\n\n## Uso de `loc` (Etiquetas) {.smaller}\n\nSintaxis: `df.loc[<etiqueta_fila>, <etiqueta_columna>]`\n\n::: {#c1a19654 .cell execution_count=6}\n``` {.python .cell-code}\nprint(df.loc['a'])              # Fila con indice 'a'\nprint(df.loc['a':'b'])          # Rango (INCLUSIVO el final)\nprint(df.loc[:, 'Mes'])         # Columna 'Mes'\n\n# Filtros Booleanos\nprint(df.loc[df.Mes == 'Enero']) # Filas donde Mes es Enero\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMes       Enero\nVentas      100\nName: a, dtype: object\n       Mes  Ventas\na    Enero     100\nb  Febrero     200\na      Enero\nb    Febrero\nc      Marzo\nName: Mes, dtype: object\n     Mes  Ventas\na  Enero     100\n```\n:::\n:::\n\n\n## Acceso Escalar (Optimizado)\n\nSi solo necesitamos **un solo valor**, usamos métodos rápidos:\n\n* `iat[fila, col]`: Por posición numérica.\n* `at[etiqueta_fila, etiqueta_col]`: Por nombre.\n\n::: {#1ece43d0 .cell execution_count=7}\n``` {.python .cell-code}\nvalor = df.at['b', 'Ventas'] # Fila 'b', Columna 'Ventas'\nprint(f\"Ventas de Febrero: {valor}\")\n\n# Modificar valor\ndf.at['b', 'Ventas'] = 500\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVentas de Febrero: 200\n```\n:::\n:::\n\n\n# Manejo de Archivos \n\n## Lectura de CSV y Excel\n\nFunciones `read_csv` y `read_excel`.\n\n**Parámetros Importantes:**\n\n* `sep`: Delimitador (coma, punto y coma).\n* `header`: Fila donde están los títulos (None si no hay).\n* `index_col`: Qué columna usar como índice del DataFrame.\n* `encoding`: 'utf-8' o 'latin-1' para tildes.\n\n```python\ndf = pd.read_csv('datos.csv', sep=';', encoding='utf-8')\ndf_xls = pd.read_excel('datos.xlsx', sheet_name='Hoja1')\n\n```\n\n## Escritura de Archivos\n\nExportar DataFrames procesados.\n\n::: {#98855616 .cell execution_count=8}\n``` {.python .cell-code}\n# CSV\ndf.to_csv('nuevo_archivo.csv', index=False) # index=False evita guardar el indice 0,1,2...\n\n# Excel (Requiere engine='openpyxl' o 'xlsxwriter')\nwriter = pd.ExcelWriter('reporte.xlsx', engine='openpyxl')\ndf.to_excel(writer, sheet_name='Resumen')\nwriter.save()\n```\n:::\n\n\n# Operaciones con DataFrames \n\n## Concatenación\n\nUnir DataFrames \"uno debajo del otro\" (axis=0) o \"uno al lado del otro\" (axis=1).\n\n::: {#fba222e2 .cell execution_count=9}\n``` {.python .cell-code}\ndf1 = pd.DataFrame({'A': [1, 2]})\ndf2 = pd.DataFrame({'A': [3, 4]})\n\nresultado = pd.concat([df1, df2], ignore_index=True)\nprint(resultado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   A\n0  1\n1  2\n2  3\n3  4\n```\n:::\n:::\n\n\n## Fusión (Merge) {.smaller}\n\nCombina tablas basándose en una columna común (clave), similar a SQL JOIN.\n\n`pd.merge(izq, der, on=\"clave\", how=\"tipo\")`\n\n| Tipo (how) | Descripción |\n| --- | --- |\n| `inner` | (Intersección) Solo lo que coincide en ambos. |\n| `outer` | (Unión) Todo. Rellena con NaN si falta info. |\n| `left` | Todo lo de la tabla izquierda y coincidencias de la derecha. |\n| `right` | Viceversa del left. |\n\n## Limpieza de Datos\n\nEliminar información irrelevante o corrupta.\n\n* **Drop:** Eliminar filas o columnas.\n* `df.drop('Columna', axis=1)`\n\n\n* **Manejo de Nulos (NaN):**\n* `df.dropna()`: Elimina filas con huecos.\n* `df.fillna(0)`: Rellena los huecos con un valor (ej. 0).\n\n\n\n# Agrupación y Análisis \n\n## GroupBy\n\nPermite dividir los datos en grupos y aplicar cálculos (contar, sumar, promediar).\n\nSintaxis: `df.groupby(by='Columna').funcion()`\n\n::: {#1ab9a428 .cell execution_count=10}\n``` {.python .cell-code}\ndata = {'Dieta': ['A','A','B','B'], 'Peso': [80, 82, 70, 75]}\ndf_g = pd.DataFrame(data)\n\n# Promedio de peso por tipo de Dieta\nprint(df_g.groupby('Dieta')['Peso'].mean())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDieta\nA    81.0\nB    72.5\nName: Peso, dtype: float64\n```\n:::\n:::\n\n\n## Agregaciones Múltiples\n\nPodemos pedir varias estadísticas a la vez usando `agg()`.\n\n::: {#d1153846 .cell execution_count=11}\n``` {.python .cell-code}\n# Media, Mínimo y Máximo por grupo\nresumen = df_g.groupby('Dieta').agg(['mean', 'min', 'max'])\nprint(resumen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Peso        \n       mean min max\nDieta              \nA      81.0  80  82\nB      72.5  70  75\n```\n:::\n:::\n\n\n# Funciones Avanzadas: Lambda \n\n## Funciones Anónimas (Lambda)\n\nSon funciones rápidas, de una sola línea, ideales para aplicar a columnas enteras.\n\nEstructura: `lambda argumentos : expresión`\n\n::: {#81e1bda6 .cell execution_count=12}\n``` {.python .cell-code}\ndoble = lambda x: x * 2\nprint(doble(5))\n\n# Condicional en lambda\nes_par = lambda x: True if x%2 == 0 else False\nprint(es_par(4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\nTrue\n```\n:::\n:::\n\n\n## Lambda en DataFrames (Apply)\n\nUsamos `apply()` para ejecutar la función en cada elemento de una columna.\n\n::: {#7b915c26 .cell execution_count=13}\n``` {.python .cell-code}\ndf = pd.DataFrame({'Precio': [100, 200, 300]})\n\n# Calcular IVA (19%) para cada precio\ndf['IVA'] = df['Precio'].apply(lambda x: x * 0.19)\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Precio   IVA\n0     100  19.0\n1     200  38.0\n2     300  57.0\n```\n:::\n:::\n\n\n# Series Temporales \n\n## Manejo de Fechas\n\nPandas es potente para analizar patrones en el tiempo.\n\n1. **Conversión:** `pd.to_datetime()` convierte texto a objetos de fecha reales.\n2. **Índice Temporal:** Usar la fecha como índice facilita filtrar por años o meses.\n\n::: {#090fa1b9 .cell execution_count=14}\n``` {.python .cell-code}\ndf_t = pd.DataFrame({'Fecha':['2023-01-01', '2023-02-01'], 'Val':[10,20]})\ndf_t['Fecha'] = pd.to_datetime(df_t['Fecha'])\ndf_t.set_index('Fecha', inplace=True)\n\n# Extraer propiedades\nprint(df_t.index.month_name())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIndex(['January', 'February'], dtype='object', name='Fecha')\n```\n:::\n:::\n\n\n## Resampling y Agrupación Temporal\n\nPodemos agrupar datos por periodicidad (mensual, anual) fácilmente.\n\n::: {#63caf098 .cell execution_count=15}\n``` {.python .cell-code}\n# Sumar casos por Nombre de Mes\ndf.groupby(df.index.month_name()).sum()\n\n# Filtrar un rango de fechas\ndf.loc['2021-01':'2021-03']\n```\n:::\n\n\n# Visualización Básica \n\n## Intro a Matplotlib\n\nLibrería estándar para gráficos en Python. Se integra nativamente con Pandas.\n\n::: {#736f098b .cell execution_count=16}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\ndf = pd.DataFrame({'X':[1,2,3], 'Y':[10,30,20]})\n\n# Gráfico de línea simple\nplt.plot(df.X, df.Y)\nplt.title(\"Ejemplo Simple\")\n# plt.show() # Necesario en scripts, automático en notebooks\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\nText(0.5, 1.0, 'Ejemplo Simple')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](programming_04_pandas_files/figure-revealjs/cell-17-output-2.png){width=802 height=431}\n:::\n:::\n\n\n## Anatomía de una Gráfica\n\nPodemos personalizar todos los elementos:\n\n* `plt.plot()`: Líneas.\n* `plt.bar()`: Barras.\n* `plt.xlabel()` / `plt.ylabel()`: Etiquetas de ejes.\n* `plt.legend()`: Leyenda de las series.\n\n```\n\n```\n\n",
    "supporting": [
      "programming_04_pandas_files\\figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}